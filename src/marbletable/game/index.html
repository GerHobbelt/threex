<!DOCTYPE html>
<!-- include three.js stuff -->
<script src='../../../vendor/three.js/build/three.min.js'></script>
<script src='../../../vendor/three.js/examples/js/modifiers/SubdivisionModifier.js'></script>
<!-- include require.js stuff -->
<script src="../../../vendor/require.js/require.js"></script>
<!-- include threex.cannonjs -->
<script src='../../threex.cannonjs/vendor/cannon.js/build/cannon.min.js'></script>
<script src='../../threex.cannonjs/threex.cannonworld.js'></script>
<script src='../../threex.cannonjs/threex.cannonbody.js'></script>
<!-- include threex.keyboardstate -->
<script src="../../threex.keyboardstate/threex.keyboardstate.js"></script>
<!-- include threex.windowresize -->
<script src="../../threex.windowresize/threex.windowresize.js"></script>
<!-- include for threex.glowdatgui -->
<script src='../../../vendor/three.js/examples/js/libs/dat.gui.min.js'></script>
<script src="../../threex.glow/threex.glowdatgui.js"></script>
<!-- include for threex.mirrorball -->
<script src='../../threex.mirrorball/threex.mirrorball.js'></script>


<script src='vendor/microcache.js'></script>
<script src='vendor/microevent.js'></script>

<!-- include for threex.mirrorball -->
<script src='vendor/webaudiox/build/webaudiox.js'></script>
<!-- include the .js files for jsfx.js -->
<script src="vendor/webaudiox/examples/vendor/jsfx/audio.js"></script>
<script src="vendor/webaudiox/examples/vendor/jsfx/jsfx.js"></script>
<script src="vendor/webaudiox/examples/vendor/jsfx/jsfxlib.js"></script>

<script src='js/initlighting.js'></script>
<script src='js/gametimer.js'></script>
<script src='js/impactballemitter.js'></script>
<script src='js/soundsinit.js'></script>

<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'>

<body><style>
#timer {
	position	: absolute;
	top		: 0px;
	right		: 0;
	z-index		: 1;

	font-family	: arial, verdana, sans-serif;
	font-size	: 300%;
	font-weight	: bolder;

	color		: #000;
	text-shadow	: 0 0 0.2em #fbc, 0 0 0.2em #fbc, 0 0 0.2em #fbc;

	padding-left	: 10px;
	padding-right	: 10px;
}
</style>
<div id="timer">Ready ?</div>
<script>
require([ '../../threex.glow/package.require.js'
	, '../../threex.skymap/package.require.js'
], function(){
	var renderer	= new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	var updateFcts	= [];
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100 );
	camera.position.x = 0
	camera.position.y = 5
	camera.position.z = 6;
	camera.lookAt( scene.position )

	var physicsWorld= new THREEx.CannonWorld().start()

	var tileW	= 0.2;

	var cache	= new Microcache();

	window.yeller	= MicroeventMixin({});
	
	// setup winResize
	var winResize	= new THREEx.WindowResize(renderer, camera)

	// init lighting
	initLighting(renderer, scene)
	
	// init keyboard		
	var keyboard	= new THREEx.KeyboardState(renderer.domElement);
	renderer.domElement.setAttribute("tabIndex", "0");
	renderer.domElement.focus();


	// add a skymap	
	var mesh	= THREEx.createSkymap('skybox')
	scene.add( mesh );

	// upadte sounds
	updateFcts.push(function(delta, now){
		sounds.update(delta. now)
	})

	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////


	var gameTimer	= new GameTimer()
	updateFcts.push(function(delta, now){
		gameTimer.update(delta. now)
	})

//////////////////////////////////////////////////////////////////////////////////
//		ball								//
//////////////////////////////////////////////////////////////////////////////////

	// fetch the texture
	var texture	= THREE.ImageUtils.loadTexture('images/rocks.jpg');
	texture.wrapS	= texture.wrapT = THREE.RepeatWrapping;
	texture.repeat.set( 4, 4 );
	texture.anisotropy	= 16
	
var ball	= (function(){
	var radius	= 1.5 * tileW
	var geometry	= new THREE.SphereGeometry(radius, 32, 32)
	var material	= new THREE.MeshPhongMaterial({
		map	: texture,
		bumpMap	: texture,
		bumpScale: 0.01
	})
	var mesh	= new THREE.Mesh(geometry, material)

	mesh.position.y	= 3
	mesh.receiveShadow	= true
	mesh.castShadow		= true
	scene.add( mesh )
	mesh.useQuaternion	= true
	var bodyx	= new THREEx.CannonBody({
		mesh	: mesh,
	}).addTo(physicsWorld)
	var body	= bodyx.origin
	updateFcts.push(function(delta, now){
		bodyx.update(delta, now)
	})

	body.angularDamping	= 0.98
	body.linearDamping	= 0.5
	
	// ugly way to fix a missing 'onLoad()'
	// 
	setTimeout(function timeoutCb(){
		if( !sounds.rollBuffer ){
			setTimeout(timeoutCb, 100)
			return;
		}
		sounds.playRoll(mesh)
	}, 100)

	
	var impactEmitter	= new ImpactBallEmitter(scene)
	updateFcts.push(function(delta, now){
		impactEmitter.update(delta, now)
	})
	
	// make a sound on collision
	bodyx.origin.addEventListener("collide",function(event){
		if( !sounds )	return;
		var speed	= bodyx.origin.velocity.norm();
		var volume	= speed/5;
		sounds.playKick(volume);

		var nEmit	= 0
		if( speed < 1.5 )	nEmit = 1;
		else if( speed < 4.5 )	nEmit = 2;
		else if( speed < 6.5 )	nEmit = 4;
		else			nEmit = 8;
		for(var i = 0; i < nEmit; i++){
			impactEmitter.emit(mesh.position)		
		}

	});

	return mesh
})()

	yeller.addEventListener('spawnPlayer', function(){
		console.log('spawnPlayer')

		gameTimer.timerBegin	= Date.now();
		gameTimer.timerEnd	= null;

		disablePlayerControls	= false

		sounds.playSpawn();

		var body	= ball.userData.cannonBody.origin
		body.position.set(+22*tileW, 2, -13*tileW)
		body.velocity.set(0,0,0)
		body.angularVelocity.set(0,0,0)
	})
			
	yeller.addEventListener('killPlayer', function(){
		console.log('killPlayer')
		sounds.playDie()
		gameTimer.timerEnd	= Date.now();

		var body	= ball.userData.cannonBody.origin
		body.velocity.set(0,0,0)
		body.angularVelocity.set(0,0,0)

		var worldPoint	= new CANNON.Vec3(ball.position.x, ball.position.y, ball.position.z)
		var impulse	= new CANNON.Vec3(0,1.1,0)
		body.applyImpulse(impulse, worldPoint);

		disablePlayerControls	= true
		setTimeout(function(){
			yeller.dispatchEvent('spawnPlayer')
		}, 0.8*1000)
	})

	//////////////////////////////////////////////////////////////////////////////////
	//		camera controls							//
	//////////////////////////////////////////////////////////////////////////////////
			
	// THREEx.TrackerControls	= function(tracked, source, target){
	// 	this.source	= source
	// 	this.target	= target
	// 	var sourcePos	= new THREE.Vector3()
	// 	var targetPos	= new THREE.Vector3()
	// 	this.update	= function(delta, now){
	// 		// compute world position for source
	// 		this.source.updateMatrixWorld();
	// 		sourcePos.getPositionFromMatrix( this.source.matrixWorld )
	// 		// compute world position for target
	// 		this.target.updateMatrixWorld();
	// 		targetPos.getPositionFromMatrix( this.target.matrixWorld )
	// 		// make tracked to fit those contrainst
	// 		tracked.position.copy(sourcePos)
	// 		tracked.lookAt(targetPos)
	// 	}
	// }

	// var cameraHolder	= new THREE.Object3D
	// scene.add(cameraHolder)

	// updateFcts.push(function(delta, now){
	// 	cameraHolder.position.copy(ball.position)
	// 	cameraHolder.position.x	+= 0
	// 	cameraHolder.position.y	+= 3
	// 	cameraHolder.position.z	+= 3		
	// })
	
	// var controls	= new THREEx.TrackerControls(camera, cameraHolder, ball)
	// updateFcts.push(function(delta, now){
	// 	controls.update(delta, now)
	// })
	
	//////////////////////////////////////////////////////////////////////////
	//		User Controls						//
	//////////////////////////////////////////////////////////////////////////
	var disablePlayerControls	= false
	updateFcts.push(function(delta, now){
		// if disablePlayerControls is true, return now
		if( disablePlayerControls )	return
		
		// prevent controls if the ball isnt on the ground
		if( ball.position.y > ball.geometry.radius )	return

		var force	= new THREE.Vector3()
		if( keyboard.pressed('right') ){
			force.x	= +1
		}else if( keyboard.pressed('left') ){
			force.x	= -1
		}
		if( keyboard.pressed('up') ){
			force.z	= -1
		}else if( keyboard.pressed('down') ){
			force.z	= +1
		}
		force.multiplyScalar(1)


		// rotate the force according to camera position
		// - thus arrow are relative to what the user see
		var forceAngle	= Math.PI/2 - Math.atan2(camera.position.z, camera.position.x)
		var matrix	= new THREE.Matrix4().makeRotationY( forceAngle )
		force.applyMatrix4( matrix )

		// apply the force to the center of the ball
		ball.updateMatrixWorld();
		// get world position
		var ballPosition= new THREE.Vector3().getPositionFromMatrix( ball.matrixWorld )

		// do an impulse to the ball
		var body	= ball.userData.cannonBody.origin
		var worldPoint	= new CANNON.Vec3(ballPosition.x, ballPosition.y, ballPosition.z)
		var impulse	= new CANNON.Vec3(force.x*delta, force.y*delta, force.z*delta)
		body.applyImpulse(impulse, worldPoint);
		// var cforce	= new CANNON.Vec3(force.x, force.y, force.z)
		// body.applyForce(cforce, worldPoint);
	})

	// jump on space
	keyboard.domElement.addEventListener('keydown', function(event){
		if( keyboard.eventMatches(event, 'escape') === false )	return
		yeller.dispatchEvent('killPlayer')
	})

	// jump on space
	keyboard.domElement.addEventListener('keydown', function(event){
		// if disablePlayerControls is true, return now
		if( disablePlayerControls )	return;		
		// prevent controls if the ball isnt on the ground
		if( ball.position.y > ball.geometry.radius*2 )	return;			

		if( keyboard.eventMatches(event, 'space') === false )	return


		sounds.playEatPill()

		// apply the force to the center of the ball
		ball.updateMatrixWorld();
		// get world position
		var ballPosition= new THREE.Vector3().getPositionFromMatrix( ball.matrixWorld )

		// do an impulse to the ball
		var body	= ball.userData.cannonBody.origin
		var worldPoint	= new CANNON.Vec3(ballPosition.x, ballPosition.y, ballPosition.z)
		var impulse	= new CANNON.Vec3()
		impulse.y	= 1/2
		body.applyImpulse(impulse, worldPoint);
	})

//////////////////////////////////////////////////////////////////////////////////
//		comment								//
//////////////////////////////////////////////////////////////////////////////////

	var table	= new THREE.Object3D()
	scene.add(table)
	// add the ground
	addGround(-35*tileW, -20*tileW, 35*tileW, 20*tileW)

	addWallGridLine(-25,-14,-25, 14)
	addWallGridLine(-25, 15, 25, 15)
	addWallGridLine( 25, 14, 25,-14)
	addWallGridLine( 25,-15,-25,-15)

	addWallGridLine( 19,-14, 19, -6)
	addWallGridLine( 24,  4, 11,  4)
	addWallGridLine( 10,  4, 10, -5)
	addWallGridLine(  9, -5,-12, -5)
	addWallGridLine(-13, -7,-13, -1)
	addWallGridLine(-20, -3,-17, -3)
	addWallGridLine(-21,  4,-21,  7)
	addWallGridLine(-16,  7,-16, 10)

	addWallGridLine( -6, 14, -6,  3)
	addWallGridLine( -5,  3, -1,  3)
	addWallGridLine(  0,  3,  0,  8)
	addWallGridLine(  6, 11,  9, 11)
	
	addHole( 16,-12)
	addHole( 13,  1)
	addHole(-11, -7)
	addHole(-22,-12)
	addHole(-13,  1)
	addHole(-22, 12)
	addHole(- 9, 12)
	addHole(  2,  8)
	addHole( 13,  9)



	//////////////////////////////////////////////////////////////////////////////////
	//		render the scene						//
	//////////////////////////////////////////////////////////////////////////////////
	updateFcts.push(function(){
		renderer.render( scene, camera );		
	})

	//////////////////////////////////////////////////////////////////////////////////
	//		loop runner							//
	//////////////////////////////////////////////////////////////////////////////////
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		updateFcts.forEach(function(updateFn){
			updateFn(deltaMsec/1000, nowMsec/1000)
		})
	})


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//		function to build the level					//
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

	function addWallGridLine(gridX1, gridZ1, gridX2, gridZ2){
		if( gridX1 === gridX2 ){
			addWallVert(gridX1, gridZ1, gridZ2)
		}else if( gridZ1 === gridZ2 ){
			addWallHori(gridZ1, gridX1, gridX2)
		}else	console.assert(false);
	}
	function addWallHori(gridZ, gridX1, gridX2){
		if( gridX1 > gridX2 ){
			var tmp	= gridX2;
			gridX2	= gridX1;
			gridX1	= tmp;
		}
		var xMin	= gridX1*tileW - tileW/2;
		var zMin	= gridZ *tileW - tileW/2;
		var xMax	= gridX2*tileW + tileW/2;
		var zMax	= gridZ *tileW + tileW/2;
		return addWall(xMin, zMin, xMax, zMax)
	}
	function addWallVert(gridX, gridZ1, gridZ2){
		if( gridZ1 > gridZ2 ){
			var tmp	= gridZ2;
			gridZ2	= gridZ1;
			gridZ1	= tmp;
		}
		var xMin	= gridX *tileW - tileW/2;
		var zMin	= gridZ1*tileW - tileW/2;
		var xMax	= gridX *tileW + tileW/2;
		var zMax	= gridZ2*tileW + tileW/2;
		return addWall(xMin, zMin, xMax, zMax)
	}
	function addWall(x1, z1, x2, z2){
		var texture	= cache.getSet('texture.wood', function(){
			return THREE.ImageUtils.loadTexture('images/wood.jpg')
		});
		
		var width	= Math.abs(x2 - x1);
		var height	= 0.5;
		var depth	= Math.abs(z2 - z1);
		var geometry	= new THREE.CubeGeometry(width, height, depth)
		var material	= new THREE.MeshPhongMaterial({
			map	: texture,
			color	: 0xcccccc
		})
		material.map.wrapS	= THREE.RepeatWrapping;
		material.map.wrapT	= THREE.RepeatWrapping;
		
		// adapt the UVs to the cube size - to avoid to strech the texture 
		var faceVertexUvs	= geometry.faceVertexUvs[0];
		faceVertexUvs[0].forEach(function(vector){ vector.x *= depth;	})
		faceVertexUvs[1].forEach(function(vector){ vector.x *= depth;	})
		faceVertexUvs[4].forEach(function(vector){ vector.x *= width;	})
		faceVertexUvs[5].forEach(function(vector){ vector.x *= width;	})


		var mesh	= new THREE.Mesh(geometry, material)
		mesh.position.x	= x1 + width/2
		mesh.position.y	=      height/2
		mesh.position.z	= z1 + depth/2

		mesh.receiveShadow	= true
		mesh.castShadow		= true

		table.add( mesh )

		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}

	function addGround(x1, z1, x2, z2){
		var texture	= cache.getSet('texture.plywood', function(){
			return THREE.ImageUtils.loadTexture('images/plywood.jpg')
		})
		var width	= Math.abs(x2 - x1)
		var height	= 0.25
		var depth	= Math.abs(z2 - z1)
		var geometry	= new THREE.CubeGeometry(width, height, depth)
		var material	= new THREE.MeshPhongMaterial({
			color		: 0xffffff,
			map		: texture,
			bumpMap		: texture,
			bumpScale	: 0.25,
		})
		texture.wrapS	= THREE.RepeatWrapping;
		texture.wrapT	= THREE.RepeatWrapping;
		texture.repeat.x= 20
		texture.repeat.y= 20

		var mesh	= new THREE.Mesh(geometry, material)
		table.add( mesh )

		mesh.position.x	= x1 + width/2
		mesh.position.y	=     -height/2
		mesh.position.z	= z1 + depth/2		
		mesh.receiveShadow	= true
		mesh.castShadow		= true


		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}
	
	function addHole(gridX, gridZ){
		var texture	= cache.getSet('texture.rocks', function(){
			return THREE.ImageUtils.loadTexture('images/rocks.jpg')
		})
		var radius	= 1.5 * tileW
		var geometry	= new THREE.SphereGeometry(radius, 32, 16)
		var material	= new THREE.MeshPhongMaterial({
			color		: new THREE.Color().setHSL(Math.random(),1,0.5),
			map		: texture,
			bumpMap		: texture,
			bumpScale	: 0.01,
		})
		texture.wrapS	= THREE.RepeatWrapping;
		texture.wrapT	= THREE.RepeatWrapping;
		texture.repeat.x= 20
		texture.repeat.y= 20

		var mesh	= new THREE.Mesh(geometry, material)
		table.add( mesh )

		mesh.position.x	= gridX * tileW
		mesh.position.z	= gridZ * tileW		

		mesh.receiveShadow	= true
		mesh.castShadow		= true


		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
		
		body.origin.addEventListener("collide",function(event){
			yeller.dispatchEvent('killPlayer')
		})
	}
})
</script></body>
