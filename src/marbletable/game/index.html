<!DOCTYPE html>
<!-- include three.js stuff -->
<script src='../../../vendor/three.js/build/three.min.js'></script>
<script src='../../../vendor/three.js/examples/js/modifiers/SubdivisionModifier.js'></script>
<!-- include require.js stuff -->
<script src="../../../vendor/require.js/require.js"></script>
<!-- include threex.cannonjs -->
<script src='../../threex.cannonjs/vendor/cannon.js/build/cannon.min.js'></script>
<script src='../../threex.cannonjs/threex.cannonworld.js'></script>
<script src='../../threex.cannonjs/threex.cannonbody.js'></script>
<!-- include threex.keyboardstate -->
<script src="../../threex.keyboardstate/threex.keyboardstate.js"></script>
<!-- include threex.windowresize -->
<script src="../../threex.windowresize/threex.windowresize.js"></script>
<!-- include for threex.glowdatgui -->
<script src='../../../vendor/three.js/examples/js/libs/dat.gui.min.js'></script>
<script src="../../threex.glow/threex.glowdatgui.js"></script>
<!-- include for threex.mirrorball -->
<script src='../../threex.mirrorball/threex.mirrorball.js'></script>


<!-- include for threex.mirrorball -->
<script src='../../webaudiox/webaudiox.js'></script>

<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'><script>
require([ '../../threex.glow/package.require.js'
	, '../../threex.skymap/package.require.js'
], function(){
	var renderer	= new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	var updateFcts	= [];
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100 );
	camera.position.x = 0
	camera.position.y = 5
	camera.position.z = 6;
	camera.lookAt( scene.position )

	var physicsWorld= new THREEx.CannonWorld().start()

	// fetch the texture
	var texture	= THREE.ImageUtils.loadTexture('images/rocks.jpg');
	texture.wrapS	= texture.wrapT = THREE.RepeatWrapping;
	texture.repeat.set( 4, 4 );
	texture.anisotropy	= 16
	
	var tileW	= 0.2;

	var cache	= new Microcache();

	// add a skymap	
	var mesh	= THREEx.createSkymap('skybox')
	scene.add( mesh );
	
	var winResize	= new THREEx.WindowResize(renderer, camera)

	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////

	renderer.shadowMapEnabled	= true
	//renderer.shadowMapType	= THREE.PCFSoftShadowMap

;(function(){
	var light	= new THREE.AmbientLight( 0x444444 )
	scene.add( light )

	var light	= new THREE.DirectionalLight( 0xcccccc, 1 )
	light.position.set(5,5,5)
	light.target.position.set( 0, 0, 0 )

	light.castShadow	= true
	light.shadowCameraNear	= 0.01
	light.shadowCameraFar	= 15
	light.shadowCameraFov	= 45

	light.shadowCameraLeft	= -8
	light.shadowCameraRight	=  8
	light.shadowCameraTop	=  5
	light.shadowCameraBottom= -5

	//light.shadowCameraVisible = true

	light.shadowBias	= 0.001
	light.shadowDarkness	= 0.5

	light.shadowMapWidth	= 1024
	light.shadowMapHeight	= 1024

	scene.add( light )
})();


//////////////////////////////////////////////////////////////////////////////////
//		ball								//
//////////////////////////////////////////////////////////////////////////////////

var ball	= (function(){
	var radius	= 1.5 * tileW
	var geometry	= new THREE.SphereGeometry(radius, 32, 32)
	var material	= new THREE.MeshPhongMaterial({
		map	: texture,
		bumpMap	: texture,
		bumpScale: 0.01
	})
	var mesh	= new THREE.Mesh(geometry, material)

	mesh.position.y	= 3
	mesh.receiveShadow	= true
	mesh.castShadow		= true
	scene.add( mesh )
console.log('ball', mesh)
	mesh.useQuaternion	= true
	var body	= new THREEx.CannonBody({
		mesh	: mesh,
	}).addTo(physicsWorld)
	updateFcts.push(function(delta, now){
		body.update(delta, now)
	})
	return mesh
})()

//////////////////////////////////////////////////////////////////////////////////
//		comment								//
//////////////////////////////////////////////////////////////////////////////////
	var webAudiox	= new WebAudiox()
	var sounds	= {}

	// init eatPill sound
	sounds.playEatPill	= function(){
		if( !sounds.eatPillBuffer )	return
		var source	= webAudiox.context.createBufferSource()
		source.buffer	= sounds.eatPillBuffer
		source.connect(webAudiox.masterOut)
		source.start(0)
	}
	webAudiox.loadBuffer('sounds/eatpill.mp3', function(buffer){
		sounds.eatPillBuffer	= buffer;
	})

	webAudiox.loadBuffer('sounds/roll.mp3', function(buffer){
		var source	= webAudiox.context.createBufferSource();
		source.buffer	= buffer;
		source.loop	= true
		source.connect(webAudiox.masterOut);
		source.start(0);

		updateFcts.push(function(delta, now){
			// compute body speed
			var body	= ball.userData.cannonBody.origin
			var speed	= body.velocity.norm();
			// set playbackRate depending on speed
			source.playbackRate.value	= 0.0001 + speed * 0.9;
			// if the ball dont touch the ground, gain is 0
			var onGround		= body.position.y >= 0.25 && body.position.y <= 0.3;
			source.gain.value	= onGround ? 1 : 0;
		})
	});


//////////////////////////////////////////////////////////////////////////////////
//		comment								//
//////////////////////////////////////////////////////////////////////////////////

	var table	= new THREE.Object3D()
	scene.add(table)
	// add the ground
	addGround(-35*tileW, -20*tileW, 35*tileW, 20*tileW)

	addWallGridLine(-25,-14,-25, 14)
	addWallGridLine(-25, 15, 25, 15)
	addWallGridLine( 25, 14, 25,-14)
	addWallGridLine( 25,-15,-25,-15)

	addWallGridLine( 19,-14, 19, -6)
	addWallGridLine( 24,  4, 11,  4)
	addWallGridLine( 10,  4, 10, -5)
	addWallGridLine(  9, -5,-12, -5)
	addWallGridLine(-13, -7,-13, -1)
	addWallGridLine(-20, -3,-17, -3)
	addWallGridLine(-21,  4,-21,  7)
	addWallGridLine(-16,  7,-16, 10)

	addWallGridLine( -6, 14, -6,  3)
	addWallGridLine( -5,  3, -1,  3)
	addWallGridLine(  0,  3,  0,  8)
	addWallGridLine(  6, 11,  9, 11)
	
	addHole( 16,-12)
	addHole( 13,  1)
	addHole(-11, -7)
	addHole(-22,-12)
	addHole(-13,  1)
	addHole(-22, 12)
	addHole(- 9, 12)
	addHole(  2,  8)
	addHole( 13,  9)

	//////////////////////////////////////////////////////////////////////////////////
	//		init keyboard								//
	//////////////////////////////////////////////////////////////////////////////////
	
	var keyboard	= new THREEx.KeyboardState(renderer.domElement);
	renderer.domElement.setAttribute("tabIndex", "0");
	renderer.domElement.focus();

	//////////////////////////////////////////////////////////////////////////
	//		User Controls						//
	//////////////////////////////////////////////////////////////////////////
	var disablePlayerControls	= false
	updateFcts.push(function(delta, now){
		// if disablePlayerControls is true, return now
		if( disablePlayerControls )	return
		
		// prevent controls if the ball isnt on the ground
		if( ball.position.y > ball.geometry.radius )	return

		var force	= new THREE.Vector3()
		if( keyboard.pressed('right') ){
			force.x	= +1
		}else if( keyboard.pressed('left') ){
			force.x	= -1
		}
		if( keyboard.pressed('up') ){
			force.z	= -1
		}else if( keyboard.pressed('down') ){
			force.z	= +1
		}
		force.multiplyScalar(1)


		// rotate the force according to camera position
		// - thus arrow are relative to what the user see
		var forceAngle	= Math.PI/2 - Math.atan2(camera.position.z, camera.position.x)
		var matrix	= new THREE.Matrix4().makeRotationY( forceAngle )
		force.applyMatrix4( matrix )

		// apply the force to the center of the ball
		ball.updateMatrixWorld();
		// get world position
		var ballPosition= new THREE.Vector3().getPositionFromMatrix( ball.matrixWorld )

		// do an impulse to the ball
		var ballBody	= ball.userData.cannonBody.origin
		var worldPoint	= new CANNON.Vec3(ballPosition.x, ballPosition.y, ballPosition.z)
		// var impulse	= new CANNON.Vec3(force.x*delta, force.y*delta, force.z*delta)
		// ballBody.applyImpulse(impulse, worldPoint);
		var cforce	= new CANNON.Vec3(force.x, force.y, force.z)
		ballBody.applyForce(cforce, worldPoint);
	})

	// jump on space
	keyboard.domElement.addEventListener('keydown', function(event){
		// if disablePlayerControls is true, return now
		if( disablePlayerControls )	return;		
		// prevent controls if the ball isnt on the ground
		if( ball.position.y > ball.geometry.radius*2 )	return;			

		if( keyboard.eventMatches(event, 'space') === false )	return


		sounds.playEatPill()

		// apply the force to the center of the ball
		ball.updateMatrixWorld();
		// get world position
		var ballPosition= new THREE.Vector3().getPositionFromMatrix( ball.matrixWorld )

		// do an impulse to the ball
		var ballBody	= ball.userData.cannonBody.origin
		var worldPoint	= new CANNON.Vec3(ballPosition.x, ballPosition.y, ballPosition.z)
		var impulse	= new CANNON.Vec3()
		impulse.y	= 1/2
		ballBody.applyImpulse(impulse, worldPoint);		
	})


	//////////////////////////////////////////////////////////////////////////////////
	//		render the scene						//
	//////////////////////////////////////////////////////////////////////////////////
	updateFcts.push(function(){
		renderer.render( scene, camera );		
	})

	//////////////////////////////////////////////////////////////////////////////////
	//		loop runner							//
	//////////////////////////////////////////////////////////////////////////////////
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		updateFcts.forEach(function(updateFn){
			updateFn(deltaMsec/1000, nowMsec/1000)
		})
	})


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//		function to build the level					//
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

	function addWallGridLine(gridX1, gridZ1, gridX2, gridZ2){
		if( gridX1 === gridX2 ){
			addWallVert(gridX1, gridZ1, gridZ2)
		}else if( gridZ1 === gridZ2 ){
			addWallHori(gridZ1, gridX1, gridX2)
		}else	console.assert(false);
	}
	function addWallHori(gridZ, gridX1, gridX2){
		if( gridX1 > gridX2 ){
			var tmp	= gridX2;
			gridX2	= gridX1;
			gridX1	= tmp;
		}
		var xMin	= gridX1*tileW - tileW/2;
		var zMin	= gridZ *tileW - tileW/2;
		var xMax	= gridX2*tileW + tileW/2;
		var zMax	= gridZ *tileW + tileW/2;
		return addWall(xMin, zMin, xMax, zMax)
	}
	function addWallVert(gridX, gridZ1, gridZ2){
		if( gridZ1 > gridZ2 ){
			var tmp	= gridZ2;
			gridZ2	= gridZ1;
			gridZ1	= tmp;
		}
		var xMin	= gridX *tileW - tileW/2;
		var zMin	= gridZ1*tileW - tileW/2;
		var xMax	= gridX *tileW + tileW/2;
		var zMax	= gridZ2*tileW + tileW/2;
		return addWall(xMin, zMin, xMax, zMax)
	}
	function addWall(x1, z1, x2, z2){
		var texture	= cache.getSet('texture.wood', function(){
			return THREE.ImageUtils.loadTexture('images/wood.jpg')
		});
		
		var width	= Math.abs(x2 - x1);
		var height	= 0.5;
		var depth	= Math.abs(z2 - z1);
		var geometry	= new THREE.CubeGeometry(width, height, depth)
		var material	= new THREE.MeshPhongMaterial({
			map	: texture,
			color	: 0xcccccc
		})
		material.map.wrapS	= THREE.RepeatWrapping;
		material.map.wrapT	= THREE.RepeatWrapping;
		
		// adapt the UVs to the cube size - to avoid to strech the texture 
		var faceVertexUvs	= geometry.faceVertexUvs[0];
		faceVertexUvs[0].forEach(function(vector){ vector.x *= depth;	})
		faceVertexUvs[1].forEach(function(vector){ vector.x *= depth;	})
		faceVertexUvs[4].forEach(function(vector){ vector.x *= width;	})
		faceVertexUvs[5].forEach(function(vector){ vector.x *= width;	})


		var mesh	= new THREE.Mesh(geometry, material)
		mesh.position.x	= x1 + width/2
		mesh.position.y	=      height/2
		mesh.position.z	= z1 + depth/2

		mesh.receiveShadow	= true
		mesh.castShadow		= true

		table.add( mesh )

		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}

	function addGround(x1, z1, x2, z2){
		var texture	= cache.getSet('texture.plywood', function(){
			return THREE.ImageUtils.loadTexture('images/plywood.jpg')
		})
		var width	= Math.abs(x2 - x1)
		var height	= 0.25
		var depth	= Math.abs(z2 - z1)
		var geometry	= new THREE.CubeGeometry(width, height, depth)
		var material	= new THREE.MeshPhongMaterial({
			color		: 0xffffff,
			map		: texture,
			bumpMap		: texture,
			bumpScale	: 0.25,
		})
		texture.wrapS	= THREE.RepeatWrapping;
		texture.wrapT	= THREE.RepeatWrapping;
		texture.repeat.x= 20
		texture.repeat.y= 20

		var mesh	= new THREE.Mesh(geometry, material)
		table.add( mesh )

		mesh.position.x	= x1 + width/2
		mesh.position.y	=     -height/2
		mesh.position.z	= z1 + depth/2		
		mesh.receiveShadow	= true
		mesh.castShadow		= true


		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}
	
	function addHole(gridX, gridZ){
		var texture	= cache.getSet('texture.rocks', function(){
			return THREE.ImageUtils.loadTexture('images/rocks.jpg')
		})
		var radius	= 1.5 * tileW
		var geometry	= new THREE.SphereGeometry(radius, 32, 16)
		var material	= new THREE.MeshPhongMaterial({
			color		: 0xaaaaaa,
			map		: texture,
			bumpMap		: texture,
			bumpScale	: 0.01,
		})
		texture.wrapS	= THREE.RepeatWrapping;
		texture.wrapT	= THREE.RepeatWrapping;
		texture.repeat.x= 20
		texture.repeat.y= 20

		var mesh	= new THREE.Mesh(geometry, material)
		table.add( mesh )

		mesh.position.x	= gridX * tileW
		mesh.position.z	= gridZ * tileW		

		mesh.receiveShadow	= true
		mesh.castShadow		= true


		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}
	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////

	/**
	 * https://github.com/jeromeetienne/MicroCache.js
	*/
	function Microcache(){
		var _values	= {};
		return {
			get	: function(key){ return _values[key];	},
			contains: function(key){ return key in _values;	},
			remove	: function(key){ delete _values[key];	},
			set	: function(key, value){	_values[key] = value;},
			values	: function(){ return _values;	},
			getSet	: function(key, value){
				if( !this.contains(key) ){
					this.set(key, typeof value == 'function' ? value() : value )
				}
				return this.get(key);
			}
		}
	}
})
</script></body>
