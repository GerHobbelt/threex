<!DOCTYPE html>
<!-- include three.js stuff -->
<script src='../../../vendor/three.js/build/three.min.js'></script>
<script src='../../../vendor/three.js/examples/js/modifiers/SubdivisionModifier.js'></script>
<!-- include require.js stuff -->
<script src="../../../vendor/require.js/require.js"></script>
<!-- include threex.cannonjs -->
<script src='../../threex.cannonjs/vendor/cannon.js/build/cannon.min.js'></script>
<script src='../../threex.cannonjs/threex.cannonworld.js'></script>
<script src='../../threex.cannonjs/threex.cannonbody.js'></script>
<!-- include threex.keyboardstate -->
<script src="../../threex.keyboardstate/threex.keyboardstate.js"></script>
<!-- include threex.windowresize -->
<script src="../../threex.windowresize/threex.windowresize.js"></script>
<!-- include for threex.glowdatgui -->
<script src='../../../vendor/three.js/examples/js/libs/dat.gui.min.js'></script>
<script src="../../threex.glow/threex.glowdatgui.js"></script>
<!-- include for threex.mirrorball -->
<script src='../../threex.mirrorball/threex.mirrorball.js'></script>


<script src='vendor/microcache.js'></script>

<!-- include for threex.mirrorball -->
<script src='vendor/webaudiox/build/webaudiox.js'></script>
<!-- include the .js files for jsfx.js -->
<script src="vendor/webaudiox/examples/vendor/jsfx/audio.js"></script>
<script src="vendor/webaudiox/examples/vendor/jsfx/jsfx.js"></script>
<script src="vendor/webaudiox/examples/vendor/jsfx/jsfxlib.js"></script>

<script src='js/lightinginit.js'></script>
<script src='js/impactballemitter.js'></script>

<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'><script>
require([ '../../threex.glow/package.require.js'
	, '../../threex.skymap/package.require.js'
], function(){
	var renderer	= new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	var updateFcts	= [];
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100 );
	camera.position.x = 0
	camera.position.y = 5
	camera.position.z = 6;
	camera.lookAt( scene.position )

	var physicsWorld= new THREEx.CannonWorld().start()

	// fetch the texture
	var texture	= THREE.ImageUtils.loadTexture('images/rocks.jpg');
	texture.wrapS	= texture.wrapT = THREE.RepeatWrapping;
	texture.repeat.set( 4, 4 );
	texture.anisotropy	= 16
	
	var tileW	= 0.2;

	var cache	= new Microcache();

	// add a skymap	
	var mesh	= THREEx.createSkymap('skybox')
	scene.add( mesh );
	
	var winResize	= new THREEx.WindowResize(renderer, camera)

	initLighting(renderer, scene)

//////////////////////////////////////////////////////////////////////////////////
//		ball								//
//////////////////////////////////////////////////////////////////////////////////

var ball	= (function(){
	var radius	= 1.5 * tileW
	var geometry	= new THREE.SphereGeometry(radius, 32, 32)
	var material	= new THREE.MeshPhongMaterial({
		map	: texture,
		bumpMap	: texture,
		bumpScale: 0.01
	})
	var mesh	= new THREE.Mesh(geometry, material)

	mesh.position.y	= 3
	mesh.receiveShadow	= true
	mesh.castShadow		= true
	scene.add( mesh )
	mesh.useQuaternion	= true
	var bodyx	= new THREEx.CannonBody({
		mesh	: mesh,
	}).addTo(physicsWorld)
	updateFcts.push(function(delta, now){
		bodyx.update(delta, now)
	})

	var impactEmitter	= new ImpactBallEmitter(scene)
	updateFcts.push(function(delta, now){
		impactEmitter.update(delta, now)
	})
	
	// make a sound on collision
	bodyx.origin.addEventListener("collide",function(event){
		if( !sounds )	return;
		var speed	= bodyx.origin.velocity.norm();
		var volume	= speed/5;
		sounds.playKick(volume);
		
		impactEmitter.emit(mesh.position)
		impactEmitter.emit(mesh.position)
	});

	return mesh
})()

	//////////////////////////////////////////////////////////////////////////////////
	//		webaudiox							//
	//////////////////////////////////////////////////////////////////////////////////
	var contextx	= new WebAudiox.Contextx()
	contextx.volume	= 1

	var sounds	= {}

	sounds.updateFcts	= [];
	sounds.update	= function(delta, now){
		sounds.updateFcts.forEach(function(updateFct){
			updateFct(delta, now)
		})
	}

	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////
	
	// init eatPill sound
	sounds.playEatPill	= function(){
		if( !sounds.eatPillBuffer )	return
		var source	= contextx.context.createBufferSource()
		source.buffer	= sounds.eatPillBuffer
		source.connect(contextx.masterOut)
		source.start(0)
	}
	WebAudiox.loadBuffer(contextx.context, 'sounds/eatpill.mp3', function(buffer){
		sounds.eatPillBuffer	= buffer;
	})

	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////
	
	// init kick sound
	sounds.playKick	= function(volume){
		if( !sounds.kickBuffer )	return
		var destination	= contextx.masterOut

		var volumeGain	= contextx.context.createGain()
		volumeGain.connect(destination)
		volumeGain.gain.value	= volume
		destination	= volumeGain

		var source	= contextx.context.createBufferSource()
		source.buffer	= sounds.kickBuffer
		source.connect(destination)
		source.start(0)		
	}
	WebAudiox.loadBuffer(contextx.context, 'sounds/kick.wav', function(buffer){
		sounds.kickBuffer	= buffer;
	})
	
	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////
	


	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////

	
	// --
	WebAudiox.loadBuffer(contextx.context, 'sounds/roll.mp3', function(buffer){
		var source	= contextx.context.createBufferSource();
		source.buffer	= buffer;
		source.loop	= true
		source.connect(contextx.masterOut);
		source.start(0);

		sounds.updateFcts.push(function(delta, now){
			// compute body speed
			var body	= ball.userData.cannonBody.origin
			var speed	= body.velocity.norm();
			// set playbackRate depending on speed
			source.playbackRate.value	= 0.0001 + speed * 0.9;
			// if the ball dont touch the ground, gain is 0
			var onGround		= body.position.y >= 0.25 && body.position.y <= 0.3;
			source.gain.value	= onGround ? 1 : 0;
		})
	});

	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////
	
	// init a sound with jsfx
	sounds.playSpawn	= function(){
		if( !sounds.noiseBuffer )	return
		var source	= contextx.context.createBufferSource()
		source.buffer	= sounds.noiseBuffer
		source.connect(contextx.masterOut)
		source.start(0)
	}
	var lib		= ["square",0.0000,0.4000,0.0000,0.3200,0.0000,0.2780,20.0000,496.0000,2400.0000,0.4640,0.0000,0.0000,0.0100,0.0003,0.0000,0.0000,0.0000,0.0235,0.0000,0.0000,0.0000,0.0000,1.0000,0.0000,0.0000,0.0000,0.0000]
	sounds.noiseBuffer	= WebAudiox.getBufferFromJsfx(contextx.context, lib)

	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////

	updateFcts.push(function(delta, now){
		sounds.update(delta. now)
	})
	
	
	//////////////////////////////////////////////////////////////////////////////////
	//		init keyboard								//
	//////////////////////////////////////////////////////////////////////////////////
	
	var keyboard	= new THREEx.KeyboardState(renderer.domElement);
	renderer.domElement.setAttribute("tabIndex", "0");
	renderer.domElement.focus();

	//////////////////////////////////////////////////////////////////////////
	//		User Controls						//
	//////////////////////////////////////////////////////////////////////////
	var disablePlayerControls	= false
	updateFcts.push(function(delta, now){
		// if disablePlayerControls is true, return now
		if( disablePlayerControls )	return
		
		// prevent controls if the ball isnt on the ground
		if( ball.position.y > ball.geometry.radius )	return

		var force	= new THREE.Vector3()
		if( keyboard.pressed('right') ){
			force.x	= +1
		}else if( keyboard.pressed('left') ){
			force.x	= -1
		}
		if( keyboard.pressed('up') ){
			force.z	= -1
		}else if( keyboard.pressed('down') ){
			force.z	= +1
		}
		force.multiplyScalar(1)


		// rotate the force according to camera position
		// - thus arrow are relative to what the user see
		var forceAngle	= Math.PI/2 - Math.atan2(camera.position.z, camera.position.x)
		var matrix	= new THREE.Matrix4().makeRotationY( forceAngle )
		force.applyMatrix4( matrix )

		// apply the force to the center of the ball
		ball.updateMatrixWorld();
		// get world position
		var ballPosition= new THREE.Vector3().getPositionFromMatrix( ball.matrixWorld )

		// do an impulse to the ball
		var ballBody	= ball.userData.cannonBody.origin
		var worldPoint	= new CANNON.Vec3(ballPosition.x, ballPosition.y, ballPosition.z)
		// var impulse	= new CANNON.Vec3(force.x*delta, force.y*delta, force.z*delta)
		// ballBody.applyImpulse(impulse, worldPoint);
		var cforce	= new CANNON.Vec3(force.x, force.y, force.z)
		ballBody.applyForce(cforce, worldPoint);
	})

	// jump on space
	keyboard.domElement.addEventListener('keydown', function(event){
		// if disablePlayerControls is true, return now
		if( disablePlayerControls )	return;		
		// prevent controls if the ball isnt on the ground
		if( ball.position.y > ball.geometry.radius*2 )	return;			

		if( keyboard.eventMatches(event, 'space') === false )	return


		sounds.playEatPill()

		// apply the force to the center of the ball
		ball.updateMatrixWorld();
		// get world position
		var ballPosition= new THREE.Vector3().getPositionFromMatrix( ball.matrixWorld )

		// do an impulse to the ball
		var ballBody	= ball.userData.cannonBody.origin
		var worldPoint	= new CANNON.Vec3(ballPosition.x, ballPosition.y, ballPosition.z)
		var impulse	= new CANNON.Vec3()
		impulse.y	= 1/2
		ballBody.applyImpulse(impulse, worldPoint);		
	})

//////////////////////////////////////////////////////////////////////////////////
//		comment								//
//////////////////////////////////////////////////////////////////////////////////

	var table	= new THREE.Object3D()
	scene.add(table)
	// add the ground
	addGround(-35*tileW, -20*tileW, 35*tileW, 20*tileW)

	addWallGridLine(-25,-14,-25, 14)
	addWallGridLine(-25, 15, 25, 15)
	addWallGridLine( 25, 14, 25,-14)
	addWallGridLine( 25,-15,-25,-15)

	addWallGridLine( 19,-14, 19, -6)
	addWallGridLine( 24,  4, 11,  4)
	addWallGridLine( 10,  4, 10, -5)
	addWallGridLine(  9, -5,-12, -5)
	addWallGridLine(-13, -7,-13, -1)
	addWallGridLine(-20, -3,-17, -3)
	addWallGridLine(-21,  4,-21,  7)
	addWallGridLine(-16,  7,-16, 10)

	addWallGridLine( -6, 14, -6,  3)
	addWallGridLine( -5,  3, -1,  3)
	addWallGridLine(  0,  3,  0,  8)
	addWallGridLine(  6, 11,  9, 11)
	
	addHole( 16,-12)
	addHole( 13,  1)
	addHole(-11, -7)
	addHole(-22,-12)
	addHole(-13,  1)
	addHole(-22, 12)
	addHole(- 9, 12)
	addHole(  2,  8)
	addHole( 13,  9)



	//////////////////////////////////////////////////////////////////////////////////
	//		render the scene						//
	//////////////////////////////////////////////////////////////////////////////////
	updateFcts.push(function(){
		renderer.render( scene, camera );		
	})

	//////////////////////////////////////////////////////////////////////////////////
	//		loop runner							//
	//////////////////////////////////////////////////////////////////////////////////
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		updateFcts.forEach(function(updateFn){
			updateFn(deltaMsec/1000, nowMsec/1000)
		})
	})


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//		function to build the level					//
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

	function addWallGridLine(gridX1, gridZ1, gridX2, gridZ2){
		if( gridX1 === gridX2 ){
			addWallVert(gridX1, gridZ1, gridZ2)
		}else if( gridZ1 === gridZ2 ){
			addWallHori(gridZ1, gridX1, gridX2)
		}else	console.assert(false);
	}
	function addWallHori(gridZ, gridX1, gridX2){
		if( gridX1 > gridX2 ){
			var tmp	= gridX2;
			gridX2	= gridX1;
			gridX1	= tmp;
		}
		var xMin	= gridX1*tileW - tileW/2;
		var zMin	= gridZ *tileW - tileW/2;
		var xMax	= gridX2*tileW + tileW/2;
		var zMax	= gridZ *tileW + tileW/2;
		return addWall(xMin, zMin, xMax, zMax)
	}
	function addWallVert(gridX, gridZ1, gridZ2){
		if( gridZ1 > gridZ2 ){
			var tmp	= gridZ2;
			gridZ2	= gridZ1;
			gridZ1	= tmp;
		}
		var xMin	= gridX *tileW - tileW/2;
		var zMin	= gridZ1*tileW - tileW/2;
		var xMax	= gridX *tileW + tileW/2;
		var zMax	= gridZ2*tileW + tileW/2;
		return addWall(xMin, zMin, xMax, zMax)
	}
	function addWall(x1, z1, x2, z2){
		var texture	= cache.getSet('texture.wood', function(){
			return THREE.ImageUtils.loadTexture('images/wood.jpg')
		});
		
		var width	= Math.abs(x2 - x1);
		var height	= 0.5;
		var depth	= Math.abs(z2 - z1);
		var geometry	= new THREE.CubeGeometry(width, height, depth)
		var material	= new THREE.MeshPhongMaterial({
			map	: texture,
			color	: 0xcccccc
		})
		material.map.wrapS	= THREE.RepeatWrapping;
		material.map.wrapT	= THREE.RepeatWrapping;
		
		// adapt the UVs to the cube size - to avoid to strech the texture 
		var faceVertexUvs	= geometry.faceVertexUvs[0];
		faceVertexUvs[0].forEach(function(vector){ vector.x *= depth;	})
		faceVertexUvs[1].forEach(function(vector){ vector.x *= depth;	})
		faceVertexUvs[4].forEach(function(vector){ vector.x *= width;	})
		faceVertexUvs[5].forEach(function(vector){ vector.x *= width;	})


		var mesh	= new THREE.Mesh(geometry, material)
		mesh.position.x	= x1 + width/2
		mesh.position.y	=      height/2
		mesh.position.z	= z1 + depth/2

		mesh.receiveShadow	= true
		mesh.castShadow		= true

		table.add( mesh )

		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}

	function addGround(x1, z1, x2, z2){
		var texture	= cache.getSet('texture.plywood', function(){
			return THREE.ImageUtils.loadTexture('images/plywood.jpg')
		})
		var width	= Math.abs(x2 - x1)
		var height	= 0.25
		var depth	= Math.abs(z2 - z1)
		var geometry	= new THREE.CubeGeometry(width, height, depth)
		var material	= new THREE.MeshPhongMaterial({
			color		: 0xffffff,
			map		: texture,
			bumpMap		: texture,
			bumpScale	: 0.25,
		})
		texture.wrapS	= THREE.RepeatWrapping;
		texture.wrapT	= THREE.RepeatWrapping;
		texture.repeat.x= 20
		texture.repeat.y= 20

		var mesh	= new THREE.Mesh(geometry, material)
		table.add( mesh )

		mesh.position.x	= x1 + width/2
		mesh.position.y	=     -height/2
		mesh.position.z	= z1 + depth/2		
		mesh.receiveShadow	= true
		mesh.castShadow		= true


		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}
	
	function addHole(gridX, gridZ){
		var texture	= cache.getSet('texture.rocks', function(){
			return THREE.ImageUtils.loadTexture('images/rocks.jpg')
		})
		var radius	= 1.5 * tileW
		var geometry	= new THREE.SphereGeometry(radius, 32, 16)
		var material	= new THREE.MeshPhongMaterial({
			color		: 0xaaaaaa,
			map		: texture,
			bumpMap		: texture,
			bumpScale	: 0.01,
		})
		texture.wrapS	= THREE.RepeatWrapping;
		texture.wrapT	= THREE.RepeatWrapping;
		texture.repeat.x= 20
		texture.repeat.y= 20

		var mesh	= new THREE.Mesh(geometry, material)
		table.add( mesh )

		mesh.position.x	= gridX * tileW
		mesh.position.z	= gridZ * tileW		

		mesh.receiveShadow	= true
		mesh.castShadow		= true


		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}
})
</script></body>
