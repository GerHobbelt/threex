<!DOCTYPE html>
<!-- include three.js stuff -->
<script src='../../../vendor/three.js/build/three.min.js'></script>
<script src='../../../vendor/three.js/examples/js/modifiers/SubdivisionModifier.js'></script>
<!-- include require.js stuff -->
<script src="../../../vendor/require.js/require.js"></script>
<!-- include threex.cannonjs -->
<script src='../../threex.cannonjs/vendor/cannon.js/build/cannon.min.js'></script>
<script src='../../threex.cannonjs/threex.cannonworld.js'></script>
<script src='../../threex.cannonjs/threex.cannonbody.js'></script>
<!-- include threex.keyboardstate -->
<script src="../../threex.keyboardstate/threex.keyboardstate.js"></script>
<!-- include threex.windowresize -->
<script src="../../threex.windowresize/threex.windowresize.js"></script>

<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'><script>
require([ '../../threex.glow/package.require.js'
], function(){
	var renderer	= new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	var updateFcts	= [];
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100 );
	camera.position.x = 0
	camera.position.y = 5
	camera.position.z = 6;
	camera.lookAt( scene.position )

	var physicsWorld= new THREEx.CannonWorld().start()

	// fetch the texture
	var texture	= THREE.ImageUtils.loadTexture('images/rocks.jpg');
	texture.wrapS	= texture.wrapT = THREE.RepeatWrapping;
	texture.repeat.set( 4, 4 );
	texture.anisotropy	= 16
	
	var tileW	= 0.2;

	var cache	= new Microcache();
	
	
	var winResize	= new THREEx.WindowResize(renderer, camera)

	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////

	renderer.shadowMapEnabled	= true
	//renderer.shadowMapType	= THREE.PCFSoftShadowMap

;(function(){
	var light	= new THREE.AmbientLight( 0x444444 )
	scene.add( light )

	var light	= new THREE.DirectionalLight( 0xcccccc, 1 )
	light.position.set(5,5,5)
	light.target.position.set( 0, 0, 0 )

	light.castShadow	= true
	light.shadowCameraNear	= 0.01
	light.shadowCameraFar	= 15
	light.shadowCameraFov	= 45

	light.shadowCameraLeft	= -8
	light.shadowCameraRight	=  8
	light.shadowCameraTop	=  5
	light.shadowCameraBottom= -5

	//light.shadowCameraVisible = true

	light.shadowBias	= 0.001
	light.shadowDarkness	= 0.5

	light.shadowMapWidth	= 1024
	light.shadowMapHeight	= 1024

	scene.add( light )
})();


//////////////////////////////////////////////////////////////////////////////////
//		dominos								//
//////////////////////////////////////////////////////////////////////////////////

;(function(){
	// build domino geometry and material
	var radius	= 1.5 * tileW
	var radius	= 3 * tileW
	var geometry	= new THREE.SphereGeometry(radius, 32, 32)
	var material	= new THREE.MeshPhongMaterial({
		map	: texture,
		bumpMap	: texture,
		bumpScale: 0.01
	})

	var mesh	= new THREE.Mesh(geometry, material)
	mesh.position.y	= 3
	mesh.castShadow	= true
	mesh.userData.domClasses	+= ' glowing'

	scene.add( mesh )
	window.ball	= mesh

	mesh.useQuaternion	= true
	var body	= new THREEx.CannonBody({
		mesh	: mesh
	}).addTo(physicsWorld)
	updateFcts.push(function(delta, now){
		body.update(delta, now)
	})
})()

	var table	= new THREE.Object3D()
	scene.add(table)
	// add the ground
	addGround(-35*tileW, -20*tileW, 35*tileW, 20*tileW)

	addWallGridLine(-25,-14,-25, 14)
	addWallGridLine(-25, 15, 25, 15)
	addWallGridLine( 25, 14, 25,-14)
	addWallGridLine( 25,-15,-25,-15)

	addWallGridLine( 19,-14, 19, -6)
	addWallGridLine( 24,  4, 11,  4)
	addWallGridLine( 10,  4, 10, -5)
	addWallGridLine(  9, -5,-12, -5)
	addWallGridLine(-13, -7,-13, -1)
	addWallGridLine(-20, -3,-17, -3)
	addWallGridLine(-21,  4,-21,  7)
	addWallGridLine(-16,  7,-16, 10)

	addWallGridLine( -6, 14, -6,  3)
	addWallGridLine( -5,  3, -1,  3)
	addWallGridLine(  0,  3,  0,  8)
	addWallGridLine(  6, 11,  9, 11)
	
	addHole( 16,-12)
	addHole( 13,  1)
	addHole(-11, -7)
	addHole(-22,-12)
	addHole(-13,  1)
	addHole(-22, 12)
	addHole(- 9, 12)
	addHole(  2,  8)
	addHole( 13,  9)

	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////
	var gravityAxis	= new THREE.AxisHelper(2)
	gravityAxis.position.y	= 2;
	table.add(gravityAxis)
	
	var keyboard	= new THREEx.KeyboardState(renderer.domElement);
	renderer.domElement.setAttribute("tabIndex", "0");
	renderer.domElement.focus();
	updateFcts.push(function(delta, now){
		if( keyboard.pressed('left') ){
			table.rotation.z -= 1 * delta;			
		}else if( keyboard.pressed('right') ){
			table.rotation.z += 1 * delta;
		}
		if( keyboard.pressed('down') ){
			table.rotation.x += 1 * delta;		
		}else if( keyboard.pressed('up') ){
			table.rotation.x -= 1 * delta;		
		}
		// stabilise
		table.rotation.x	*= 0.95
		table.rotation.z	*= 0.97
		
		gravityAxis.rotation.z	= -table.rotation.z
		gravityAxis.rotation.x	= -table.rotation.x
	})
	
	updateFcts.push(function(delta, now){
		if( keyboard.pressed('space') ){
			var ballBody	= ball.userData.cannonBody.origin;
			ballBody.position.y	+= 10*delta;		
		}
	})

	//////////////////////////////////////////////////////////////////////////////////
	//		Camera Controls							//
	//////////////////////////////////////////////////////////////////////////////////
	// var mouse	= {x : 0, y : 0}
	// document.addEventListener('mousemove', function(event){
	// 	mouse.x	= (event.clientX / window.innerWidth ) - 0.5
	// 	mouse.y	= (event.clientY / window.innerHeight) - 0.5
	// }, false)
	// updateFcts.push(function(delta, now){
	// 	camera.position.x += (mouse.x*5 - camera.position.x) * (delta*3)
	// 	camera.position.y += (mouse.y*20 - camera.position.y) * (delta*3)
	// 	camera.lookAt( scene.position )
	// })


	//////////////////////////////////////////////////////////////////////////////////
	//		render the scene						//
	//////////////////////////////////////////////////////////////////////////////////
	updateFcts.push(function(){
		renderer.render( scene, camera );		
	})
	
	//////////////////////////////////////////////////////////////////////////////////
	//		loop runner							//
	//////////////////////////////////////////////////////////////////////////////////
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		updateFcts.forEach(function(updateFn){
			updateFn(deltaMsec/1000, nowMsec/1000)
		})
	})


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//		function to build the level					//
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

	function addWallGridLine(gridX1, gridZ1, gridX2, gridZ2){
		if( gridX1 === gridX2 ){
			addWallVert(gridX1, gridZ1, gridZ2)
		}else if( gridZ1 === gridZ2 ){
			addWallHori(gridZ1, gridX1, gridX2)
		}else	console.assert(false);
	}
	function addWallHori(gridZ, gridX1, gridX2){
		if( gridX1 > gridX2 ){
			var tmp	= gridX2;
			gridX2	= gridX1;
			gridX1	= tmp;
		}
		var xMin	= gridX1*tileW - tileW/2;
		var zMin	= gridZ *tileW - tileW/2;
		var xMax	= gridX2*tileW + tileW/2;
		var zMax	= gridZ *tileW + tileW/2;
		return addWall(xMin, zMin, xMax, zMax)
	}
	function addWallVert(gridX, gridZ1, gridZ2){
		if( gridZ1 > gridZ2 ){
			var tmp	= gridZ2;
			gridZ2	= gridZ1;
			gridZ1	= tmp;
		}
		var xMin	= gridX *tileW - tileW/2;
		var zMin	= gridZ1*tileW - tileW/2;
		var xMax	= gridX *tileW + tileW/2;
		var zMax	= gridZ2*tileW + tileW/2;
		return addWall(xMin, zMin, xMax, zMax)
	}
	function addWall(x1, z1, x2, z2){
		var texture	= cache.getSet('texture.wood', function(){
			return THREE.ImageUtils.loadTexture('images/wood.jpg')
		});
		
		var width	= Math.abs(x2 - x1);
		var height	= 0.5;
		var depth	= Math.abs(z2 - z1);
		var geometry	= new THREE.CubeGeometry(width, height, depth)
		var material	= new THREE.MeshPhongMaterial({
			map	: texture,
			color	: 0xcccccc
		})
		material.map.wrapS	= THREE.RepeatWrapping;
		material.map.wrapT	= THREE.RepeatWrapping;
		
		// adapt the UVs to the cube size - to avoid to strech the texture 
		var faceVertexUvs	= geometry.faceVertexUvs[0];
		faceVertexUvs[0].forEach(function(vector){ vector.x *= depth;	})
		faceVertexUvs[1].forEach(function(vector){ vector.x *= depth;	})
		faceVertexUvs[4].forEach(function(vector){ vector.x *= width;	})
		faceVertexUvs[5].forEach(function(vector){ vector.x *= width;	})


		var mesh	= new THREE.Mesh(geometry, material)
		mesh.position.x	= x1 + width/2
		mesh.position.y	=      height/2
		mesh.position.z	= z1 + depth/2

		mesh.receiveShadow	= true
		mesh.castShadow		= true

		table.add( mesh )

		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}

	function addGround(x1, z1, x2, z2){
		var texture	= cache.getSet('texture.plywood', function(){
			return THREE.ImageUtils.loadTexture('images/plywood.jpg')
		})
		var width	= Math.abs(x2 - x1)
		var height	= 0.25
		var depth	= Math.abs(z2 - z1)
		var geometry	= new THREE.CubeGeometry(width, height, depth)
		var material	= new THREE.MeshPhongMaterial({
			color		: 0xffffff,
			map		: texture,
			bumpMap		: texture,
			bumpScale	: 0.25,
		})
		texture.wrapS	= THREE.RepeatWrapping;
		texture.wrapT	= THREE.RepeatWrapping;
		texture.repeat.x= 20
		texture.repeat.y= 20

		var mesh	= new THREE.Mesh(geometry, material)
		table.add( mesh )

		mesh.position.x	= x1 + width/2
		mesh.position.y	=     -height/2
		mesh.position.z	= z1 + depth/2		
		mesh.receiveShadow	= true
		mesh.castShadow		= true


		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}
	
	function addHole(gridX, gridZ){
		var texture	= cache.getSet('texture.rocks', function(){
			return THREE.ImageUtils.loadTexture('images/rocks.jpg')
		})
		var radius	= 1.5 * tileW
		var geometry	= new THREE.SphereGeometry(radius, 32, 16)
		var material	= new THREE.MeshPhongMaterial({
			color		: 0xaaaaaa,
			map		: texture,
			bumpMap		: texture,
			bumpScale	: 0.01,
		})
		texture.wrapS	= THREE.RepeatWrapping;
		texture.wrapT	= THREE.RepeatWrapping;
		texture.repeat.x= 20
		texture.repeat.y= 20

		var mesh	= new THREE.Mesh(geometry, material)
		table.add( mesh )

		mesh.position.x	= gridX * tileW
		mesh.position.z	= gridZ * tileW		

		mesh.receiveShadow	= true
		mesh.castShadow		= true


		// init physics
		var body	= new THREEx.CannonBody({
			mesh	: mesh,
			mass	: 0
		}).addTo(physicsWorld)
		updateFcts.push(function(delta, now){
			body.update(delta, now)
		});
	}
	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////

	/**
	 * https://github.com/jeromeetienne/MicroCache.js
	*/
	function Microcache(){
		var _values	= {};
		return {
			get	: function(key){ return _values[key];	},
			contains: function(key){ return key in _values;	},
			remove	: function(key){ delete _values[key];	},
			set	: function(key, value){	_values[key] = value;},
			values	: function(){ return _values;	},
			getSet	: function(key, value){
				if( !this.contains(key) ){
					this.set(key, typeof value == 'function' ? value() : value )
				}
				return this.get(key);
			}
		}
	}
})
</script></body>
